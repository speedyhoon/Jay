# Jay

Jay aims to be the fastest production safe, serialization package written in [Go](https://go.dev) as
an alternative to
[JSON](https://pkg.go.dev/encoding/json),
[Protocol Buffers](https://pkg.go.dev/google.golang.org/protobuf), FlatBuffers,
[gob](https://pkg.go.dev/encoding/gob),
[MessagePack](https://msgpack.org),
[Bebop](https://github.com/betwixt-labs/bebop),
and [mus-go](https://github.com/mus-format/mus-go) with less setup required and no extra languages to learn.

Jay doesn't determine any types during runtime. Instead, the marshalling and unmarshalling functions are easily
generated using the [jay commandline tool](https://github.com/speedyhoon/jay/tree/master/cmd/jay).

## TLDR;

##### Pros:

* The fastest Go serialization and deserialization message format (some types use zero memory allocations).
* Encoded variables use less network overhead because no schema is added to the output when marshalling (unlike JSON).
* No custom language to learn. Jay uses Go's built in [`ast`](https://pkg.go.dev/go/ast) to find exported structs in your existing codebase.
* No hassles between client and server. Generate the code once and share _(via a Go module or copy-paste)_.
* Options to generate code optimized for:
	* Processing more requests per second _(higher CPU throughput)_ **OR**,
	* Least network bandwidth used _(10/100 networks)_.
* Doesn't introduce extra dependencies.
* Output could be compressed with `gzip`, `brotli`, [`zstd`](https://facebook.github.io/zstd/) or others.

##### Cons:

* Need to regenerate methods when Go structs are modified using the [jay commandline tool](https://github.com/speedyhoon/jay/tree/master/cmd/jay).
* Marshalled output is **not** human-readable.
* Only written for the Go language.

## Speed

Unlike JSON, Jay's marshal and unmarshal functions are generated by a command line tool.
This significantly increases execution speed during runtime by removing type reflection.

Most small structs with 10 fields can be serialized within 175 nanoseconds on old hardware _(Intel T6400 @ 2.0¬†GHz
with GM45 GPU)_.

## Install
Install the `jay` command line tool to generate marshal and unmarshal code.
```shell
go install github.com/speedyhoon/jay/generate/cmd/jay
```

## Command line tool.

1. Execute the command line tool and specify which `.go` file contains the exported structs.
	For example, `type Car struct` is located within `main.go`.
	```shell
	cd my_project_path
	jay main.go
	```
2. `jay` will then generate methods `MarshalJ()` and `UnmarshalJ([]byte)` in `jay.go` _(the default output file)_.
3. The new methods can then be used. For example,

```go
package main

import "fmt"

type Car struct {
	ID            uint
	Make, Model   string
	Auto, HasFuel bool
}

func main() {
	car := Car{ID: 42, Make: "Ford", Model: "Escort", Auto: true, HasFuel: true}
	var src []byte
	src = car.MarshalJ()
	fmt.Println(src)

	var car2 Car
	err := car2.UnmarshalJ(src)
	fmt.Printf("err: %v, %+v", err, car2)
}
```

## Message format

Exported struct fields are concatenated together in binary format, delimited by each field's length.

High-throughput mode on a 64-bit system:

```
Auto & HasFuel, ID,               Make,      Model         = 21 bytes
[192,           42,0,0,0,0,0,0,0, 4,F,o,r,d, 6,E,s,c,o,r,t]
```

Low-bandwidth mode: _(unfinished)_

```
Auto & HasFuel, ID,   Make,      Model         = 15 bytes
[192,           1,42, 4,F,o,r,d, 6,E,s,c,o,r,t]
```

## Supported types:

* `bool`, `[]bool`
* `byte`, `[]byte`
* `complex64`, `complex128`
* `[]complex64`, `[]complex128`
* `float32`, `float64`
* `[]float32`, `[]float64`
* `int`, `int8`, `int16`, `int32`, `int64`
* `[]int`, `[]int8`, `[]int16`, `[]int32`, `[]int64`
* `rune`, `[]rune`
* `string` _(Currently limited to 255 byte lengths)_
* `struct` _(Embedded structs aren't fully fuzz tested yet.)_
* `time.Time`, `time.Duration`
* `[]time.Time`, `[]time.Duration`
* `uint`, `uint8`, `uint16`, `uint32`, `uint64`
* `[]uint`, `[]uint8`, `[]uint16`, `[]uint32`, `[]uint64`
* arrays for simple types _(`[5]string` limited testing so far)_

Jay also supports imported types. If the exported type is in the same package or a subpackage then `jay` will automatically find it with:

```shell
cd my_project_directory
jay .
```

To include an external type via the commandline, either:

* Specify the imported file: <br>
  `jay myFile.go ../other_project/myImportedFile.go`
* Or include that directory: <br>
  `jay myFile.go my_imported_directory`

## TODO

In order of priority:

* Expand fuzz testing.
* Field tag options and documentation.
* `string` _(Increase supported length from 255 bytes to 16 MB)_
* slices _(including `[]string`, `[]time.Time`, `[]time.Duration`)_ <br>
  **WIP** -- type aliases are working (`type strs = []string`), undecided upon type definitions (`type strs []string`),
* Performance benchmarks.
* Low-bandwidth mode.
* Aliased definition types like `[]float` where `float` is defined as `type float float32`.<br>
  _(Already supported: `type float = float32`, `type floats = []float32` & `type floats []float32`)_.
###### Undecided
* pointers _(`*uint64`)_ <br>
  _**R&D** -- have a working prototype for `*bool` and all integer types, undecided on `*string`, slices, arrays and struct slices_.
* multi-dimensional arrays & slices? _(`[][]string`)_
* maps? _(`map[string]uint`)_

## Done

* Specify which struct types to process in a large project directory. E.g.: ```-y Animal,settings.Config,engine.Specs```
* Aliased types like `type float = float32` and `type floats = []float32`.
* Simple definition types for built-ins only like `type floats []float32`.
* Slices with lengths 0‚Äì255 _(`[]string`)_.

## Not Supported

* `interface{}` requires adding reflection and/or type switches at a significant performance and complexity cost. Either
  use a different package or write your own function to convert the `interface{}` to one of the supported types
  (a `[]byte` might be the fastest option).
* Double nested pointers (`**string`).
* Generics (`any`).
* Functions.

## Why

Conceived in 2011 as an interesting way to improve network communication.
It wasn't until 2023 when I was using `JSON` _(wasn't my choice by the way)_ to marshal and unmarshal data
between microcontrollers that it posed a significant bottleneck.
The aim was to process external messages within
a dozen microseconds to restore performance without upgrading the processor.

###### Name
**Clarification:** The serialization format is Jay, whereas `jay` is the command line tool.

Jay _(pronounced as just `J`)_ is a wordplay on [JSON](https://pkg.go.dev/encoding/json) without the `SON`, since the schema information is chopped off ü™ö and it's not human-readable.

The name Jay also gives tribute to a 17-year-old netbook with a stuck `j` key on the keyboard. üîÅ üòÜ Every boot looks like:

```
jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj
jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj
jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj
```