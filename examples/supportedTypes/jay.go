// Code generated by Jay; DO NOT EDIT. Tool documentation available at: https://github.com/speedyhoon/jay

package main

import "github.com/speedyhoon/jay"

func (s Supported) MarshalJ() (b []byte) {
	l0, l1, l2, l3, l4, l5 := len(s.String), len(s.Embed.String), len(s.Embed.ByteSlice), len(s.SubStruct.String), len(s.SubStruct.ByteSlice), len(s.ByteSlice)
	b = make([]byte, 260+l0+l1+l2+l3+l4+l5)
	b[0], b[1], b[2], b[3], b[4], b[5] = byte(l0), byte(l1), byte(l2), byte(l3), byte(l4), byte(l5)
	b[6] = jay.Bool3(s.Bool, s.Embed.Bool, s.SubStruct.Bool)
	b[7] = s.Byte
	b[8] = byte(s.Int8)
	b[9] = s.Uint8
	b[10] = s.Embed.Byte
	b[11] = byte(s.Embed.Int8)
	b[12] = s.Embed.Uint8
	b[13] = s.SubStruct.Byte
	b[14] = byte(s.SubStruct.Int8)
	b[15] = s.SubStruct.Uint8
	jay.WriteFloat32(b[16:20], s.Float32)
	jay.WriteFloat64(b[20:28], s.Float64)
	copy(b[28:44], s.Guid[:])
	jay.WriteIntX64(b[44:52], s.Int)
	jay.WriteInt16(b[52:54], s.Int16)
	jay.WriteInt32(b[54:58], s.Int32)
	jay.WriteInt64(b[58:66], s.Int64)
	jay.WriteUintX64(b[66:74], s.Uint)
	jay.WriteUint16(b[74:76], s.Uint16)
	jay.WriteUint32(b[76:80], s.Uint32)
	jay.WriteUint64(b[80:88], s.Uint64)
	jay.WriteInt32(b[88:92], s.Rune)
	jay.WriteTime(b[92:100], s.Time)
	jay.WriteTimeNano(b[100:108], s.Nano)
	jay.WriteFloat32(b[108:112], s.Embed.Float32)
	jay.WriteFloat64(b[112:120], s.Embed.Float64)
	jay.WriteIntX64(b[120:128], s.Embed.Int)
	jay.WriteInt16(b[128:130], s.Embed.Int16)
	jay.WriteInt32(b[130:134], s.Embed.Int32)
	jay.WriteInt64(b[134:142], s.Embed.Int64)
	jay.WriteUintX64(b[142:150], s.Embed.Uint)
	jay.WriteUint16(b[150:152], s.Embed.Uint16)
	jay.WriteUint32(b[152:156], s.Embed.Uint32)
	jay.WriteUint64(b[156:164], s.Embed.Uint64)
	jay.WriteInt32(b[164:168], s.Embed.Rune)
	jay.WriteTime(b[168:176], s.Embed.Time)
	jay.WriteTimeNano(b[176:184], s.Embed.Nano)
	jay.WriteFloat32(b[184:188], s.SubStruct.Float32)
	jay.WriteFloat64(b[188:196], s.SubStruct.Float64)
	jay.WriteIntX64(b[196:204], s.SubStruct.Int)
	jay.WriteInt16(b[204:206], s.SubStruct.Int16)
	jay.WriteInt32(b[206:210], s.SubStruct.Int32)
	jay.WriteInt64(b[210:218], s.SubStruct.Int64)
	jay.WriteUintX64(b[218:226], s.SubStruct.Uint)
	jay.WriteUint16(b[226:228], s.SubStruct.Uint16)
	jay.WriteUint32(b[228:232], s.SubStruct.Uint32)
	jay.WriteUint64(b[232:240], s.SubStruct.Uint64)
	jay.WriteInt32(b[240:244], s.SubStruct.Rune)
	jay.WriteTime(b[244:252], s.SubStruct.Time)
	jay.WriteTimeNano(b[252:260], s.SubStruct.Nano)
	at, end := 260, 260+l0
	copy(b[at:end], s.String)
	at, end = end, end+l1
	copy(b[at:end], s.Embed.String)
	if l2 != 0 {
		at, end = end, end+l2
		copy(b[at:end], s.Embed.ByteSlice)
	}
	at, end = end, end+l3
	copy(b[at:end], s.SubStruct.String)
	if l4 != 0 {
		at, end = end, end+l4
		copy(b[at:end], s.SubStruct.ByteSlice)
	}
	if l5 != 0 {
		copy(b[end:], s.ByteSlice)
	}
	return
}

func (s *Supported) UnmarshalJ(b []byte) error {
	l := len(b)
	if l < 260 {
		return jay.ErrUnexpectedEOB
	}
	l0, l1, l2, l3, l4, l5 := int(b[0]), int(b[1]), int(b[2]), int(b[3]), int(b[4]), int(b[5])
	if l != 260+l0+l1+l2+l3+l4+l5 {
		return jay.ErrUnexpectedEOB
	}
	s.Bool, s.Embed.Bool, s.SubStruct.Bool = jay.ReadBool3(b[6])
	s.Byte = b[7]
	s.Int8 = int8(b[8])
	s.Uint8 = b[9]
	s.Embed.Byte = b[10]
	s.Embed.Int8 = int8(b[11])
	s.Embed.Uint8 = b[12]
	s.SubStruct.Byte = b[13]
	s.SubStruct.Int8 = int8(b[14])
	s.SubStruct.Uint8 = b[15]
	s.Float32 = jay.ReadFloat32(b[16:20])
	s.Float64 = jay.ReadFloat64(b[20:28])
	s.Guid = [16]byte(b[28:44])
	s.Int = jay.ReadIntX64(b[44:52])
	s.Int16 = jay.ReadInt16(b[52:54])
	s.Int32 = jay.ReadInt32(b[54:58])
	s.Int64 = jay.ReadInt64(b[58:66])
	s.Uint = jay.ReadUintX64(b[66:74])
	s.Uint16 = jay.ReadUint16(b[74:76])
	s.Uint32 = jay.ReadUint32(b[76:80])
	s.Uint64 = jay.ReadUint64(b[80:88])
	s.Rune = jay.ReadInt32(b[88:92])
	s.Time = jay.ReadTime(b[92:100])
	s.Nano = jay.ReadTimeNano(b[100:108])
	s.Embed.Float32 = jay.ReadFloat32(b[108:112])
	s.Embed.Float64 = jay.ReadFloat64(b[112:120])
	s.Embed.Int = jay.ReadIntX64(b[120:128])
	s.Embed.Int16 = jay.ReadInt16(b[128:130])
	s.Embed.Int32 = jay.ReadInt32(b[130:134])
	s.Embed.Int64 = jay.ReadInt64(b[134:142])
	s.Embed.Uint = jay.ReadUintX64(b[142:150])
	s.Embed.Uint16 = jay.ReadUint16(b[150:152])
	s.Embed.Uint32 = jay.ReadUint32(b[152:156])
	s.Embed.Uint64 = jay.ReadUint64(b[156:164])
	s.Embed.Rune = jay.ReadInt32(b[164:168])
	s.Embed.Time = jay.ReadTime(b[168:176])
	s.Embed.Nano = jay.ReadTimeNano(b[176:184])
	s.SubStruct.Float32 = jay.ReadFloat32(b[184:188])
	s.SubStruct.Float64 = jay.ReadFloat64(b[188:196])
	s.SubStruct.Int = jay.ReadIntX64(b[196:204])
	s.SubStruct.Int16 = jay.ReadInt16(b[204:206])
	s.SubStruct.Int32 = jay.ReadInt32(b[206:210])
	s.SubStruct.Int64 = jay.ReadInt64(b[210:218])
	s.SubStruct.Uint = jay.ReadUintX64(b[218:226])
	s.SubStruct.Uint16 = jay.ReadUint16(b[226:228])
	s.SubStruct.Uint32 = jay.ReadUint32(b[228:232])
	s.SubStruct.Uint64 = jay.ReadUint64(b[232:240])
	s.SubStruct.Rune = jay.ReadInt32(b[240:244])
	s.SubStruct.Time = jay.ReadTime(b[244:252])
	s.SubStruct.Nano = jay.ReadTimeNano(b[252:260])
	at, end := 260, 260+l0
	s.String = string(b[at:end])
	at, end = end, end+l1
	s.Embed.String = string(b[at:end])
	if l2 != 0 {
		at, end = end, end+l2
		s.Embed.ByteSlice = b[at:end]
	}
	at, end = end, end+l3
	s.SubStruct.String = string(b[at:end])
	if l4 != 0 {
		at, end = end, end+l4
		s.SubStruct.ByteSlice = b[at:end]
	}
	if l5 != 0 {
		s.ByteSlice = b[end:]
	}
	return nil
}

func (e Embed) MarshalJ() (b []byte) {
	l0, l1 := len(e.String), len(e.ByteSlice)
	b = make([]byte, 82+l0+l1)
	b[0], b[1] = byte(l0), byte(l1)
	b[2] = jay.Bool1(e.Bool)
	b[3] = e.Byte
	b[4] = byte(e.Int8)
	b[5] = e.Uint8
	jay.WriteFloat32(b[6:10], e.Float32)
	jay.WriteFloat64(b[10:18], e.Float64)
	jay.WriteIntX64(b[18:26], e.Int)
	jay.WriteInt16(b[26:28], e.Int16)
	jay.WriteInt32(b[28:32], e.Int32)
	jay.WriteInt64(b[32:40], e.Int64)
	jay.WriteUintX64(b[40:48], e.Uint)
	jay.WriteUint16(b[48:50], e.Uint16)
	jay.WriteUint32(b[50:54], e.Uint32)
	jay.WriteUint64(b[54:62], e.Uint64)
	jay.WriteInt32(b[62:66], e.Rune)
	jay.WriteTime(b[66:74], e.Time)
	jay.WriteTimeNano(b[74:82], e.Nano)
	at, end := 82, 82+l0
	copy(b[at:end], e.String)
	if l1 != 0 {
		copy(b[end:], e.ByteSlice)
	}
	return
}

func (e *Embed) UnmarshalJ(b []byte) error {
	l := len(b)
	if l < 82 {
		return jay.ErrUnexpectedEOB
	}
	l0, l1 := int(b[0]), int(b[1])
	if l != 82+l0+l1 {
		return jay.ErrUnexpectedEOB
	}
	e.Bool = jay.ReadBool1(b[2])
	e.Byte = b[3]
	e.Int8 = int8(b[4])
	e.Uint8 = b[5]
	e.Float32 = jay.ReadFloat32(b[6:10])
	e.Float64 = jay.ReadFloat64(b[10:18])
	e.Int = jay.ReadIntX64(b[18:26])
	e.Int16 = jay.ReadInt16(b[26:28])
	e.Int32 = jay.ReadInt32(b[28:32])
	e.Int64 = jay.ReadInt64(b[32:40])
	e.Uint = jay.ReadUintX64(b[40:48])
	e.Uint16 = jay.ReadUint16(b[48:50])
	e.Uint32 = jay.ReadUint32(b[50:54])
	e.Uint64 = jay.ReadUint64(b[54:62])
	e.Rune = jay.ReadInt32(b[62:66])
	e.Time = jay.ReadTime(b[66:74])
	e.Nano = jay.ReadTimeNano(b[74:82])
	at, end := 82, 82+l0
	e.String = string(b[at:end])
	if l1 != 0 {
		e.ByteSlice = b[end:]
	}
	return nil
}
