package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
)

func main() {
	types := []string{
		"bool", "[]bool",
		"byte", "[]byte",
		"float32", "[]float32",
		"float64", "[]float64",
		"int", "int8", "int16", "int32", "rune", "int64",
		"[]int", "[]int8", "[]int16", "[]int32", "[]int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"[]uint", "[]uint16", "[]uint32", "[]uint64",
		"string", "[]string",
		"time.Time", "time.Duration", "[]time.Duration",
	}

	pkg := bytes.NewBufferString(`// Code generated by gen.go; DO NOT EDIT.

package main

import "time"
`)
	jayTest := bytes.NewBufferString(`// Code generated by gen.go; DO NOT EDIT.

package main

import (
	"testing"

	"github.com/speedyhoon/rando"
	"github.com/stretchr/testify/require"
)
`)

	var i uint
	for _, a := range types {
		for _, b := range types {
			if a == b {
				// Identical field types are already covered in other test directories.
				continue
			}

			_, _ = fmt.Fprintf(pkg, `
type Fuzz%d struct {
	One %s
	Two %s
}
`, i, a, b)
			_, _ = fmt.Fprintf(jayTest, `
func TestFuzz%[1]d(t *testing.T) {
	var expected, actual Fuzz%[1]d
	require.NoError(t, expected.UnmarshalJ(actual.MarshalJ()))
	require.Equal(t, expected, actual)
	require.Equal(t, Fuzz%[1]d{}, expected)
	require.Equal(t, Fuzz%[1]d{}, actual)

	actual = Fuzz%[1]d{
		One: %[2]s,
		Two: %[3]s,
	}
	src := actual.MarshalJ()
	require.NoError(t, expected.UnmarshalJ(src))
	require.Equal(t, expected, actual)
}
`, i, toRandoFunc(a), toRandoFunc(b))
			i++
		}
	}

	const perm = 0666
	err := os.WriteFile("pkg.go", pkg.Bytes(), perm)
	if err != nil {
		panic(err)
	}
	err = os.WriteFile("jay_test.go", jayTest.Bytes(), perm)
	if err != nil {
		panic(err)
	}
}

func toRandoFunc(typ string) string {
	f, ok := map[string]string{
		"bool":            "Bool",
		"[]bool":          "Bools",
		"byte":            "Byte",
		"[]byte":          "Bytes",
		"float32":         "Float32",
		"[]float32":       "Float32s",
		"float64":         "Float64",
		"[]float64":       "Float64s",
		"int":             "Int",
		"int8":            "Int8",
		"int16":           "Int16",
		"int32":           "Int32",
		"rune":            "Rune",
		"int64":           "Int64",
		"[]int":           "Ints",
		"[]int8":          "Int8s",
		"[]int16":         "Int16s",
		"[]int32":         "Int32s",
		"[]int64":         "Int64s",
		"uint":            "Uint",
		"uint8":           "Uint8",
		"uint16":          "Uint16",
		"uint32":          "Uint32",
		"uint64":          "Uint64",
		"[]uint":          "Uints",
		"[]uint16":        "Uint16s",
		"[]uint32":        "Uint32s",
		"[]uint64":        "Uint64s",
		"string":          "String",
		"[]string":        "Strings",
		"time.Time":       "Time",
		"time.Duration":   "Duration",
		"[]time.Duration": "Durations",
	}[typ]
	if !ok {
		log.Panicf("type `%s` not supported in rando package", typ)
	}

	return fmt.Sprintf("rando.%s()", f)
}
